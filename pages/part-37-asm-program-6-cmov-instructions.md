<h1>Part 37 - ASM Program 6 [CMOV Instructions]</h1><p>For a complete table of contents of all the lessons please click below as it will give you a brief of each lesson in addition to the topics it will cover. https://github.com/mytechnotalent/Reverse-Engineering-Tutorial</p><p>In our sixth program we will demonstrate how we can work with CMOV instructions.</p><p>Before we dive into some code lets talk about CMOV is. CMOV can prevent the processor from utilizing the JMP instructions and speeds up the respective binary.</p><p>There are unsigned CMOV instructions such as:</p><p>CMOVA or CMOVNBE = Above [Carry Flag or Zero Flag = 0]</p><p>CMOVAE or CMOVNB = Above Or Equal [Carry Flag = 0]</p><p>CMOVNC = Not Carry [Carry Flag = 0]</p><p>CMOVB or CMOVNAE = Below [Carry Flag = 1]</p><p>CMOVC = Carry [Carry Flag = 1]</p><p>CMOVBE or CMOVNA = Below Or Equal [Carry Flag or Zero Flag = 1]</p><p>CMOVE or CMOVZ = Equal [Zero Flag = 1]</p><p>CMOVNE or CMOVNZ = Not Equal [Zero Flag = 0]</p><p>CMOVP or CMOVPE = Parity [Parity Flag = 1]</p><p>CMOVNP or CMOVPO = Not Parity [Parity Flag =0]</p><p>There are also signed CMOV instructions such as:</p><p>CMOVGE or CMOVNL = Greater Or Equal [Sign Flag xor Overflow Flag = 0]</p><p>CMOVL or CMOVNGE = Less [Sign Flag xor Overflow Flag = 1]</p><p>CMOVLE or CMOVNG = Less Or Equal [Sign Flag xor Overflow Flag or ZF = 1]</p><p>CMOVO = Overflow [Overflow Flag = 1]</p><p>CMOVNO = Not Overflow [Overflow Flag = 0]</p><p>CMOVS = Sign NEGATIVE [Sign Flag = 1]</p><p>CMOVNS = Not Sign POSITIVE [Sign Flag = 0]</p><p>Keep in mind to review the relationships between the unsigned and signed operations. The unsigned instructions utilize the CF, ZF and PF to determine the difference between the two operands where the signed instructions utilize the SF and OF to indicate the condition of the comparison between the operands.</p><p>If you need a refresher on the flag please review Part 14 on Flags in this series.</p><p>The CMOV instructions rely on a mathematical instruction that sets the EFLAGS register to operate and therefore saves the programmer to use JMP statements after the compare statement. Lets examine some source code.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQGkSjSgGw8FFQ/article-inline_image-shrink_1000_1488/0/1520240921769?e=1614211200&amp;v=beta&amp;t=1kxFDxftHwCJGpLytbxPKgxt_YuRzgSeGvrO7O_zenw"/></div><p>Ok lets begin with lines 21 and 22. This is nothing new that we have experienced as we are simply moving the array into ebx.</p><p>On line 24 we see the find_smallest_value function to where we are cycling through the array and using the CMOVB to find the lowest value ultimately.</p><p>We see <strong>cmp %ebx, %eax</strong> to which cmp subtracts the first operand from the second and sets the EFLAGS register appropriately. At this point the cmovb is used to replace the value in ebx with the value in eax if the value is smaller than what was originally in the ebx register.</p><p>After we exit the loop we see three sets of sys_writes to first display our message, second to display our converted integer to ascii value and then finally a period and line feed.</p><p>Keep in mind to assemble we type:</p><p><strong>as –32 -o cmov_instructions.o cmov_instructions.s</strong></p><p>To link the object file we type:</p><p><strong>ld -m elf_i386 -o cmov_instructions cmov_instructions.o </strong></p><p>I look forward to seeing you all next week when we dive into debugging our sixth assembly program!</p>