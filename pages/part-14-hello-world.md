<h1>Part 14 - Hello World</h1><p>For a complete table of contents of all the lessons please click below as it will give you a brief of each lesson in addition to the topics it will cover. https://github.com/mytechnotalent/Reverse-Engineering-Tutorial</p><p>Today we begin our journey into the world of C++ and gaining a better understanding of how C++ interacts with our ARM processor.</p><p>The prior lessons in this series focus on the basics of the ARM processor and touch upon its architecture and how everything ultimately translates down to Assembly Language and then ultimately opcodes into machine language.</p><p>We start with our first program in C++ which is our “Hello World” program. Let’s dive in and break each line down step-by-step and see how this language works. We will call this <strong>example1.cpp</strong> and save it to our device.</p><pre spellcheck="false">#include &lt;iostream&gt;
 
int main(void) {
    std::cout &lt;&lt; “Hello World” std::endl;
 
    return 0;
}
</pre><div class="slate-resizable-image-embed"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQEbStDvDoxw0Q/article-inline_image-shrink_1000_1488/0/1520191083072?e=1614211200&amp;v=beta&amp;t=gV2PzS_bhVM99-q6RQUx7j3ixkhrFDHNz-BhBWa_3B0"/></div><p>To compile this we simply type:</p><pre spellcheck="false">g++ example1.cpp -o example1
</pre><p>We simply then type:</p><pre spellcheck="false">./example1
</pre><div class="slate-resizable-image-embed slate-image-embed__resize-left"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQHx4gcyoVXPIQ/article-inline_image-shrink_1000_1488/0/1520237920732?e=1614211200&amp;v=beta&amp;t=UESFqR47aiRNtsp7EGKdHhPwJzmWOKhpDsOHhWV20mE"/></div><p><br/></p><p>SUCCESS! We see “Hello World” printed to the standard output or terminal!</p><p>Lets break it down line by line:</p><p><strong>#include &lt;iostream&gt; </strong>is referred to as a preprocessor statement. These preprocessor statements happen just before the compilation of the rest of the code. The #include keyword will find a file called <strong>iostream</strong> and take all of the contents of that file and paste it into the existing code we just created. These files are also called header files. </p><p>We call <strong>iostream</strong> because we need a declaration for a function called <strong>cout</strong> and <strong>endl</strong>. The <strong>cout</strong> function allows us to print text to the standard output or terminal and the <strong>endl</strong> function creates a new line after the text has been displayed.</p><p>The main section which is of type integer is the entry point into the main application or binary. You will notice a <strong>void</strong> inside the <strong>()</strong> which indicates that it does not have any parameters which will be passed into the function.</p><p>The <strong>std </strong>indicates a namespace which is quite simply a mechanism to organize code into logical groups in order to prevent name collisions when you are dealing with multiple libraries.</p><p>You will see many examples where they declare a using namespace std; however I will NEVER utilize this approach as it can cause naming collisions in more complex applications.</p><p>The <strong>&lt;&lt;</strong> operator is referred to as an overloaded operator. They are essentially a function very similar to <strong>printf</strong> in the C language. We are simply moving the <strong>“Hello World” </strong>string into the <strong>cout</strong> function through the use of the <strong>&lt;&lt;</strong> overloaded operator. We then push the <strong>endl</strong> which creates a new line to the console.</p><p>The final line is the return 0. Since our main function is of type int, we have to return something. In C++ 11 there is no need for this in the main function however is required for every other function. I will stick to tradition and simply include it.</p><p>The next stage is that we compile the file. The first thing that occurs is the entire contents of the iostream header goes into the source file as we discussed. The compile process is where the C++ code gets translated into machine code. The next stage of compilation occurs when the rest of the lines of our existing code are parsed through. Essentially we have all of the contents of iostream into a new file and then all of the contents of our existing file added to a single file.</p><p>Compiling takes our text file the cpp file and converts it into an intermediate format called an obj file. An abstract syntax tree is created which is a conversion of constant data, variables and instructions.</p><p>Once the tree is created the code is generated. This means we now have machine code that our ARM CPU will execute. Every cpp file (translation units) which will have its own respective obj file associated with it. </p><p>Linking takes our obj files, our compiled files, in addition to the C++ Standard Library and finds where each symbol and function is and link them all together into one executable.   </p><p>The concepts above may appear a bit confusing if you are new to programming however as you code and compile and later debug and hack in Assembly Language it will all become very clear and you will learn to master the processor.</p><p>Next week we will dive into Debugging Hello World.</p>