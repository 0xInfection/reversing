<h1>Part 10 - Boolean Instructions</h1><p>For a complete table of contents of all the lessons please click below as it will give you a brief of each lesson in addition to the topics it will cover. https://github.com/mytechnotalent/Reverse-Engineering-Tutorial</p><p>x64 utilizes the flat memory model to which we have one large array of addresses that exist within the processor. </p><p>A pointer is nothing more than the address of a specific value in memory. Let’s take an example:</p><p><strong>mov rax, 0x10</strong></p><p>In this example we are moving <strong>10</strong> hex into the <strong>rax </strong>register.</p><p>To get the value inside <strong>rax</strong> at <strong>0x10,</strong> you would use the following syntax:</p><p><strong>mov rbx, word ptr [rax] </strong></p><p>Let’s assume the value inside memory <strong>0x10</strong> was <strong>0x20</strong> therefore <strong>rax </strong>points to the value inside <strong>0x10</strong> which when you dereference by <strong>[rax]</strong> contains<strong> 0x20</strong>. <strong>0x20</strong> is the value inside of the register <strong>rax</strong>.</p><p>We are moving a word value pointed inside of <strong>rax </strong> into <strong>rbx</strong>.</p><p>If we do:</p><p><strong>mov word ptr [rax], 0x66</strong></p><p>This will put the value of <strong>0x66</strong> into the memory location at <strong>0x10</strong>. We know that the value inside <strong>0x10 </strong>memory location was <strong>0x20</strong> so therefore the new value inside the memory at <strong>0x10</strong> will be <strong>0x66.</strong></p><p>This can get confusing however when we get into code over the coming months this will become more apparent. </p><p>Next week we will dive into load effective address! Stay tuned!</p>