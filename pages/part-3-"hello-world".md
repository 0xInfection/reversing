<h1>Part 3 - "Hello World"</h1><p>For a complete table of contents of all the lessons please click below as it will give you a brief of each lesson in addition to the topics it will cover. https://github.com/mytechnotalent/hacking_c-_arm64</p><p>Today we are going to debug our first program utilizing our dev build of Radare2.</p><p>If this is your first time working with Assembly I would encourage you check out this series as it may better prepare you for the upcoming lessons.</p><iframe allowfullscreen="true" class="center lazy-loaded" frameborder="0" height="294" src="https://www.linkedin.com/embeds/publishingEmbed.html?articleId=7574498398602237511" title="mytechnotalent/Reverse-Engineering-Tutorial" width="744"></iframe><p>To begin let's open up our binary in Radare2.</p><pre spellcheck="false">radare2 ./0x01_asm_64_helloworld
</pre><p>Let's take advantage of Radare2's auto analysis feature.</p><pre spellcheck="false">aaa
</pre><p>The next thing we want to do logically is fire up the program in debug mode so it maps the raw machine code from disk to a running process.</p><pre spellcheck="false">ood
</pre><p>Now that we have a running instance we can seek to the main entry point of the binary.</p><pre spellcheck="false">s main
</pre><p>Let us take an initial examination by doing the following.</p><pre spellcheck="false">v
</pre><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQGbmlq5BpJRvQ/article-inline_image-shrink_1500_2232/0/1606325530734?e=1614211200&amp;v=beta&amp;t=XlkybYoKX_nrr9rlLdtK042bxOc_mcjIiKFkUSKb3G4"/></div><p>You can right click and <strong>Open image in new tab </strong>to get an expanded view.</p><p>Remember there is a difference between an executable on disk and what resides when it is mapped. When it is on disk it is referred to as unmapped. We will look at that at the end of the lesson. For now we are looking at a mapped version as you see it is an offset of the mapped code we will examine later.</p><p>Do you notice that as your mapped memory values are different than mine? That is because of ALSR.</p><p>Address Space Layout Randomization (ASLR) is a security technique used in operating systems, first implemented in 2001. The current versions of all major operating systems (iOS, Android, Windows, macOS, and Linux) feature ASLR protection.</p><p>ASLR is primarily used to protect against buffer overflow attacks. In a buffer overflow, attackers feed a function as much junk data as it can handle, followed by a malicious payload.</p><p>We notice in my mapped memory that at address <em>0x55629cab48</em> we see our string<em> "Hello World!"</em>. You will have a different offset as we discussed but will find the same result.</p><p>Let us get back to a console window by doing the following.</p><pre spellcheck="false">q
</pre><p>Let's verify our initial analysis.</p><pre spellcheck="false">[0x55629ca9e4]&gt; ps @0x55629cab48
Hello World!
[0x55629ca9e4]&gt;
</pre><p>We can see that it is in fact true that at the mapped memory address of <em>0x55629cab48</em> we see the string <em>"Hello World!"</em>.</p><p>Let's also look at the hex view so we can see and better understand what is going on at the machine code level.</p><pre spellcheck="false">px @0x55629cab48
</pre><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQFpr4Sn53SDaQ/article-inline_image-shrink_1000_1488/0/1606325962588?e=1614211200&amp;v=beta&amp;t=lkVQRvc1_fUHdKH7BQ6xvIoyOVtd1HZuBOFS9NT-v-0"/></div><p>We see our "Hello World!" string and we can again see that it exists starting at the mapped memory address of 0x55629cab48.</p><p>We see that our machine code instructions are 16 bytes long or 64-bits long as we can see the first column start at <em>48</em> and end with <em>00</em>.</p><p>It is VERY important we understand a few key things. First is the fact that a single hex digit is 4-bits wide or a nibble or a half of a byte. In our case <em>4</em> is a half of a byte and <em>8</em> is the other half of the byte. Together they form a byte and in our case a valid ascii char code.</p><p>Let's visit the online ascii table.</p><iframe allowfullscreen="true" class="center lazy-load" data-delayed-url="https://www.linkedin.com/embeds/publishingEmbed.html?articleId=7387163987651632632" frameborder="0" height="104" src="about:blank" title="ASCII Table and Description" width="744"></iframe><p>Second, we need to understand what the machine code translates to. Let's look up what <em>48</em> is in hex. We see that it is a capital 'H'. That maps perfectly as you see in the right hand column of the image above we see a 0 and below it the letter H.</p><p>Obviously <em>65</em> hex is <strong><em>'e'</em></strong> and so on and so forth. You can extrapolate the rest for yourself now that you have a basic understanding of what you are looking at.</p><p>Let's now define a breakpoint on main and execute this binary to verify in fact that when we continue on from main it will print <em>"Hello World"</em> to the stdout.</p><pre spellcheck="false">[0x55629ca9e4]&gt; db 0x55629ca9e4
[0x55629ca9e4]&gt;
</pre><p>Let us continue and verify our hypothesis. First we continue and break on main.</p><pre spellcheck="false">[0x55629ca9e4]&gt; dc
hit breakpoint at: 0x55629ca9e4
[0x55629ca9e4]&gt;
</pre><p>Now we step again and since there are no other breakpoints we will conclude the execution and verify our result in stdout.</p><pre spellcheck="false">[0x55629ca9e4]&gt; dc
Hello World!
(59575) Process exited with status=0x0
[0x7fb146cb8c]&gt;
</pre><p>Let's exit Radare2.</p><pre spellcheck="false">q
y
y
</pre><p>Let us rerun Radare2 again and this time not run the binary and simply look at the unmapped binary that is on disk.</p><pre spellcheck="false">radare2 ./0x01_asm_64_helloworld
</pre><p>Let's auto analyze.</p><pre spellcheck="false">aaa
</pre><p>Let's seek to main.</p><pre spellcheck="false">s main
</pre><p>Then view.</p><pre spellcheck="false">v
</pre><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQFxOrN5kQQhuQ/article-inline_image-shrink_1500_2232/0/1606327203401?e=1614211200&amp;v=beta&amp;t=7ogFQ8LalKVuK3ZaYPun01rpyEmgW4wXLpy3kZpyOD0"/></div><p>You can right click and <strong>Open image in new tab </strong>to get an expanded view.</p><p>Notice that we have <em>"Hello World!"</em> this time at the unmapped memory address of <em>0xb48</em>. You notice that when you ran the binary the executable had an offset to this value but the LSB were <em>48</em> hex.</p><p>I hope this lesson helps you to understand the basics of 64-bit ARM assembly and how to reverse it properly.</p><p>In our next lesson we will hack the value.</p>