<h1>Part 15 - Debugging Hello World</h1><p>For a complete table of contents of all the lessons please click below as it will give you a brief of each lesson in addition to the topics it will cover. https://github.com/mytechnotalent/Reverse-Engineering-Tutorial</p><p>Let’s review our code from last week.</p><div class="slate-resizable-image-embed slate-image-embed__resize-middle"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQHCoWLpKrStnA/article-inline_image-shrink_1000_1488/0/1520191246374?e=1614211200&amp;v=beta&amp;t=BP5WkWSTpfH5TcIZuXBPpUM5Ab9OGo-4WqRyGfdkLOE"/></div><p>Let’s debug! Let’s fire up GDB which is the GNU Debugger to which we will break down the C++ binary and step through it line-by-line in ARM Assembly.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQGZYAS71PhOrA/article-inline_image-shrink_1000_1488/0/1520232284963?e=1614211200&amp;v=beta&amp;t=U1SQd5BzTIvmWnXa3Sd2JyjepUFEl3hE-XrPeDXUHQw"/></div><p>This is the ARM disassembly that we are seeing. No matter what language you program in, it ultimately will go down to this level. </p><p>This might be a bit scary to you if you did not take my prior course on ARM Assembly. If you need to do a refresher, please link back to that series.</p><p>You are probably asking yourself why we are not debugging with the original source code and seeing how it matches nicely to the assembly. The answer is when you are a professional Reverse Engineer, you do not get the luxury of seeing source code when you are reversing binaries. </p><p>This is a childishly simple example and we will continue through the series with very simple examples so that you can learn effective techniques. We are using a text-based debugger here so that you fully understand what is going on and to also get some training if you had to ever attach yourself to a running process inside a foreign machine you will know how to properly debug or hack.</p><p>I will focus SOLELY on this method rather than using a nice graphical debugger like IDA or the like so that you are able to manipulate at a very low-level.</p><p>We start with loading the link register into <strong>r11 </strong>and adding <strong>4</strong> to the stack pointer and then adding it to <strong>r11</strong>. This is simply a routine which will allow the binary to preserve the link register and setting up space on the stack.</p><p>We notice memory address <strong>0x10750</strong> being loaded from memory to the register <strong>r1</strong>. Let’s do a string examination and see what is located at that address.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQHnETV_0INvVA/article-inline_image-shrink_1000_1488/0/1520233136878?e=1614211200&amp;v=beta&amp;t=tzr4mmZqWAg6ddbO7s36naU0EV9Q2uqkAhcD7i55ZXg"/></div><p>Voila! We see our string. <strong>“Hello World!”</strong> located at that memory address. </p><p>Let’s set a breakpoint at <strong>main+16.</strong></p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQHqVRmT-mgyAg/article-inline_image-shrink_1000_1488/0/1520202291983?e=1614211200&amp;v=beta&amp;t=p0w9sg_Fq0HSvqEM0i4pRYDfscvcCVXQ7mza3l8on2w"/></div><p>Let’s take a look at our register values.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQGSf1zMtjTwsg/article-inline_image-shrink_1000_1488/0/1520193660539?e=1614211200&amp;v=beta&amp;t=VJzC0kMuj08Y9ShtRL5S5qKqCwlzhMhdMoZRmInP9HA"/></div><p>Let’s now take a look at what is inside the <strong>r1</strong> register and then step through the binary.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQHBFli6ZrFnyw/article-inline_image-shrink_1000_1488/0/1520235567544?e=1614211200&amp;v=beta&amp;t=lFukOryYGs2ZXhUAqTbfeoYrMmJ_LrewrtYFjV08SPI"/></div><p>We see the <strong>“Hello World!”</strong> string now residing inside of <strong>r1</strong> which resides at memory address <strong>0x10848</strong>. Finally let’s continue through the binary.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQERpBfgmUg0hQ/article-inline_image-shrink_1000_1488/0/1520190662835?e=1614211200&amp;v=beta&amp;t=jBIGsHFYMFEexcg6LT2gFwsV5VDn1WqH-lwzbl-ew1Y"/></div><p>Understanding assembly and step-by-step debugging allows you to have complete and ultimate control over any binary! More complex binaries can cause you hours, days or weeks to truly Reverse Engineer however the techniques are the same just more time consuming.</p><p>Reverse Engineering is the most sophisticated form of analysis in advanced Computer Engineering. There are many tools that a professional Reverse Engineer uses however each of those tools have a usage and purpose however this technique is the most sophisticated and comprehensive.</p><p>Next week we will dive into Hacking Hello World.</p>