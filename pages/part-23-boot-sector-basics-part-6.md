<h1>Part 23 - Boot Sector Basics [Part 6]</h1><p>For a complete table of contents of all the lessons please click below as it will give you a brief of each lesson in addition to the topics it will cover.Â https://github.com/mytechnotalent/Reverse-Engineering-Tutorial</p><p>We need to discuss memory at this point. Before we can discuss setting up a simple stack in our bootloader we must understand how memory is allocated in the bootsector.</p><p>1)<strong>0x0 = Interrupt Vector Table </strong>- This is where our interrupt table exists at the very base of memory. This is where all of our interrupt calls exist.</p><p>2)<strong>0x400 = BIOS Data Area</strong> - This stores variables about the state of the bootable device.</p><p>3)<strong>0x7c00 = Loaded Boot Sector</strong> - This has our machine code that will be loaded into RAM by the bootloader firmware (note: firmware is simply code that runs before an OS runs like what we are doing).</p><p>4)<strong>0x7e00 = Free</strong> - This is your stack area that you can develop in.</p><p>5)<strong>0x9fc00 = Extended BIOS Data Area</strong> - Holds data from disk track buffers and other connected devices as remember there is no file system as of yet.</p><p>6)<strong>0xa0000 = Video Memory</strong> - BIOS maps your video memory here at boot.</p><p>7)<strong>0xc0000 = BIOS</strong> - Where BIOS officially resides.</p><p>8)<strong>0x100000 = Free</strong> - Additional space you can develop in.</p><p>This is critical that you understand how memory is laid out at boot. In our next lesson we will create a simple stack at <strong>0x7e00</strong>.</p>