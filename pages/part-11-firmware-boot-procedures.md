<h1>Part 11 - Firmware Boot Procedures</h1><p>For a complete table of contents of all the lessons please click below as it will give you a brief of each lesson in addition to the topics it will cover. https://github.com/mytechnotalent/Reverse-Engineering-Tutorial</p><p>Let’s take a moment to talk about what happens when we first power on our Raspberry Pi device.</p><p>As soon as the Pi receives power, the graphics processor is the first thing to run as the processor is held in a reset state to which the GPU starts executing code. The ROM reads from the SD card and reads <strong>bootcode.bin </strong>to which gets loaded into memory in C2 cache and turns on the rest of the RAM to which <strong>start.elf</strong> then loads.</p><p>The <strong>start.elf </strong>is an OS for the graphics processor and reads <strong>config.txt </strong>to which you can mod. The <strong>kernel.img </strong>then gets loaded into <strong>0x8000</strong> in memory which is the Linux kernel.</p><p>Once loaded, <strong>kernel.img </strong>turns on the CPU and starts running at <strong>0x8000 </strong>in memory. </p><p>If we wanted, we could create our own <strong>kernel.img</strong> to which we can hard code machine code into a file and replace the original image and then reboot. Keep in mind the ARM word size is 32 bit long which go from bit 0 to 31. </p><p>As stated, when <strong>kernel.img</strong> is loaded the first byte, which is 8-bits, is loaded into address <strong>0x800</strong>.</p><p>Lets open up a hex editor and write the following:</p><p><strong>FE FF FF EA</strong></p><p>Save the file as <strong>kernel.img</strong> and reboot.</p><p>“Ok nothing happens, this sucks!”</p><p>Actually something did happen, you created your first bare-metal firmware! Time to break out the champagne! </p><p>When the Pi boots, the below code when it reached <strong>kernel.img </strong>loads the following:</p><p><strong>FE FF FF EA</strong></p><p><strong>@ address 0x8000, 0xfe gets loaded.</strong></p><p><strong>@ address 0x8001, 0xff gets loaded.</strong></p><p><strong>@ address 0x8002, 0xff gets loaded.</strong></p><p><strong>@ address 0x8003, 0xea gets loaded.</strong></p><p>“So what the hell is really going on?”</p><p>This set of commands simply executes an infinite loop. </p><p>Review the datasheet:</p><p><a href="https://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="nofollow noopener" target="_blank">https://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf</a></p><p>The above code has 3 parts to it:</p><p>1)Conditional – Set To Always</p><p>2)Op Code – Branch</p><p>3)Offset – How Far To Move Within The Current Location</p><p><strong>Condition – bits 31-28: 0xe or 1110</strong></p><p><strong>Op Code – bits 27-24: 0xa or 1010</strong></p><p><strong>Offset – bits 23-0 -2</strong></p><p>I know this may be a lot to wrap your mind around however it is critical that you take the time and read the datasheet linked above. Do not cut corners if you truly have the passion to understand the above. READ THE DATASHEET!</p><p>I will go through painstaking efforts to break everything down step-by-step however there are exercises like the above that I am asking you to review the datasheet above so you learn how to better understand where to look when you are stuck on a particular routine or set of machine code. This is one of those times I ask you to please read and research the datasheet above!</p><p>“I’m bored! Why the hell does this crap matter?”</p><p>Glad you asked! The single most dangerous malware on planet earth today is that of the root-kit variety. If you do not have a basic understanding of the above, you will never begin to even understand what a root-kit is as you progress in your understanding.</p><p>Anyone can simply replace the <strong>kernel.img</strong> file with their own hacked version and you can have total control over the entire process from boot.</p><p>Next week we will dive into the Von Neumann Architecture.</p>