<h1>Part 9 - Link Register</h1><p>For a complete table of contents of all the lessons please click below as it will give you a brief of each lesson in addition to the topics it will cover. https://github.com/mytechnotalent/Reverse-Engineering-Tutorial</p><p>The Link Register, R14, is used to hold the return address of a function call.</p><p>When a BL (branch with link) instruction performs a subroutine call, the link register is set to the subroutine return address. BL jumps to another location in the code and when complete allows a return to the point right after the BL code section. When the subroutine returns, the link register returns the address back to the program counter.</p><p>The link register does not require the writes and reads of the memory containing the stack which can save a considerable percentage of execution time with repeated calls of small subroutines.</p><p>When BL has executed, the return address which is the address of the next instruction to be executed, is loaded into the LR or R14. When the subroutine has finished, the LR is copied directly to the PC (Program Counter) or R15 and code execution continues where it was prior in the sequential code source.</p><p>CODE TIME! Don’t be discouraged if you don’t understand everything in the code example here. It will become clear over the next few lessons.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQGPWFIFoeU5FQ/article-inline_image-shrink_1000_1488/0/1520232099195?e=1614211200&amp;v=beta&amp;t=Id7F9An5RopHYQjnoEzWNEt7PMXMTeqJVUGDq35matM"/></div><p>To compile:</p><pre spellcheck="false">as -o lr_demo.o lr_demo.s

ld -o lr_demo lr_demo.o
</pre><p>The simple example I created here is pretty self-explanatory. We start and proceed to the <strong>no_return</strong> subroutine and proceed to the <strong>my_function</strong> subroutine then to the <strong>wrap_up</strong> subroutine and finally<strong> exit</strong>.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQFRqZj9YmvYuQ/article-inline_image-shrink_1000_1488/0/1520190659000?e=1614211200&amp;v=beta&amp;t=1Z7wGnOAHP9LPGCUbIWdMoXg1n2guXqy379ChZV-jV0"/></div><p>It is necessary that we jump into GDB which is our debugger to see exactly what happens with each step:</p><p>As you can see with every step inside the debugger it shows you exactly the progression from <strong>no_return </strong>to <strong>my_function</strong> skipping <strong>wrap_up</strong> until the program counter gets the address from the link register.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQHIvvLr67EmrA/article-inline_image-shrink_1000_1488/0/1520221355382?e=1614211200&amp;v=beta&amp;t=0X_ROhHivP864Y5ZGKFo7R_TTfkb19K421ftEeUx5Lc"/></div><p>Here we see the progression from <strong>wrap_up</strong> to <strong>exit</strong>.</p><p>This is a fundamental operation when we see next week how the stack operates as the LR is an essential part of this process.</p><p>Next week we will dive into the Stack Pointer! Stay tuned!</p>