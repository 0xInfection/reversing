<h1>Part 7 - Debugging Basic I/O</h1><p>For a complete table of contents of all the lessons please click below as it will give you a brief of each lesson in addition to the topics it will cover. https://github.com/mytechnotalent/hacking_c-_arm64</p><p>Today we hack the input validation from our last lesson. </p><p>Let's fire up radare2 in write mode.</p><pre spellcheck="false">radare2 -w ./0x02_asm_64_basicio
</pre><p>Let's auto analyze.</p><pre spellcheck="false">aaa
</pre><p>Seek to main.</p><pre spellcheck="false">s main
</pre><p>View disassembly.</p><pre spellcheck="false">v
</pre><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQErvkdMr1NFEQ/article-inline_image-shrink_1500_2232/0/1607709949903?e=1614211200&amp;v=beta&amp;t=PLgZhADmTex0JpVsuGZ0GUrCpyXc_SeF9RZEJBWGCZ4"/></div><p>You can right click and <strong>Open image in new tab </strong>to get an expanded view.</p><p>Let's get back to the terminal view.</p><pre spellcheck="false">q
</pre><p>Let's look at the visual graph and begin with the first <em>b.ne</em> which under the proper expected conditions it will only accept a valid integer between <em>0</em> and <em>100</em> as we demonstrated in the last lecture.</p><p>The <em>b.ne</em> meaning <em>branch if not equal</em>.  The assembly before it simply does not matter in this case as we know if we leave b.ne as is the input validation will be in tact.</p><p>We need to disable this input validation by changing that instruction to a <em>b.eq</em> or <em>branch if equal</em>.</p><p>Let's look at that code block.</p><div class="slate-resizable-image-embed slate-image-embed__resize-middle"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQEYu3t0SC3bOw/article-inline_image-shrink_1000_1488/0/1607710722312?e=1614211200&amp;v=beta&amp;t=uWpu45XtlcD8ya-81CE8loE_dZCYrGYZkPE7RbqlAxE"/></div><p>We see that it if it is true, meaning validation is correct and we have an integer between 0 and 100 we will follow the true green line to the next function which is as follows:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQGK6I1fEl1OLg/article-inline_image-shrink_1500_2232/0/1607710870812?e=1614211200&amp;v=beta&amp;t=IL4hUO-UCmQiZKhkpoelTiA4QzNsnsz80Pd07wdV8fU"/></div><p>You can right click and <strong>Open image in new tab </strong>to get an expanded view.</p><p>If we fail the validation we will be sent to the false condition to obtain new input:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQEVggrRbTNdSA/article-inline_image-shrink_1500_2232/0/1607710976917?e=1614211200&amp;v=beta&amp;t=YurXzwQQJnIL8iMSBlQDykrdh-XMRxd8BhxthITNgDs"/></div><p>Let's q to a terminal prompt.</p><pre spellcheck="false">qq
</pre><p>Let's seek to the statement we want to hack.</p><pre spellcheck="false">[0x000010a4]&gt; s 0x000010c4
</pre><p>Let's now hack the branch as discussed.</p><pre spellcheck="false">[0x000010c4]&gt; wa b.eq 0x1214
Written 4 byte(s) (b.eq 0x1214) = wx 800a0054
[0x000010c4]&gt;
</pre><p>Let's quit.</p><pre spellcheck="false">q
</pre><p>Now when we run the binary it will simply ignore any input at all let alone input validation and simply arrive at the desired point.</p><pre spellcheck="false">kali@kali:~/Documents/0x02_asm_64_basicio$ ./0x02_asm_64_basicio
Your are 0 years old, seems legit!
kali@kali:~/Documents/0x02_asm_64_basicio$
</pre><p>Even though 0 is valid it is simply an unstable value that happened to be in one of the registers that the program expected to be properly assigned during a normal program flow.  Here we were able to change the binary permanently to accomplish our hack.</p><p>These are VERY simple examples however when you combine these as you progress you will literally be able to Reverse Engineer anything.</p><p>In our next lesson we will discuss the char primitive data type.</p><p><br/></p><p><br/></p>