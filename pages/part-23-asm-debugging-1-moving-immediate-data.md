<h1>Part 23 - ASM Debugging 1 [Moving Immediate Data]</h1><p>For a complete table of contents of all the lessons please click below as it will give you a brief of each lesson in addition to the topics it will cover. https://github.com/mytechnotalent/Reverse-Engineering-Tutorial</p><p>Let’s begin by loading the binary into GDB.</p><p>To load into GDB type:</p><p><strong>gdb -q moving_immediate_dat</strong></p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQHzK50-MzIVnQ/article-inline_image-shrink_1000_1488/0/1520242394717?e=1614211200&amp;v=beta&amp;t=8H9xM-049QzpEtB-9JT2T_awxVh4OvNGr9I24VjnFXw"/></div><p>Let’s first set a breakpoint on start by typing b _start.</p><p>We can then run the program by typing <strong>r</strong>.</p><p>To then begin disassembly, we simply type <strong>disas</strong>.</p><p>We coded a <strong>nop</strong> which means no operation or 0x90 from an OPCODE perspective for proper debugging purposes which the breakpoint properly hit. This is good practice when creating assembly programs.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQEjmP-CAaArUA/article-inline_image-shrink_1000_1488/0/1520193761435?e=1614211200&amp;v=beta&amp;t=cOKth3OB8ny_HG8JYNsQZipzuW5LxfMlLqCc42KOayQ"/></div><p>The native syntax as I have stated many times before is AT&amp;T syntax which you see above. I painfully go back and forth deliberately so that you have comfort in each however going forward I will be sticking to the AT&amp;T syntax however wanted to show you a few examples of both. I will state again that if you ever want to see Intel syntax simply type set-disassembly-flavor intel and you will have what you are looking for.</p><p>We first use the command si which means step-into to advance to the next instruction. What we see here at <strong>_start+0</strong> is you are moving the hex value of <strong>0x64</strong> into <strong>EAX</strong>. This is simply moving decimal <strong>100</strong> or as the computer sees it, hex <strong>0x64</strong> into <strong>EAX</strong> which demonstrates moving an immediate value into a register.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQG7geAqfBOv9w/article-inline_image-shrink_1000_1488/0/1520144825193?e=1614211200&amp;v=beta&amp;t=5BD1GYM6hJhSLuCYlesz7QGkLO9xy8Xmi3VHEUVLGrw"/></div><p>We step-into again and then use the command i r which keep in mind has a space between them to give us information on the state of the CPU registers. We can see EAX now has the value of 0x64 hex or 100 decimal.</p><div class="slate-resizable-image-embed slate-image-embed__resize-middle"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQHA33plzRVMuQ/article-inline_image-shrink_1000_1488/0/1520492698882?e=1614211200&amp;v=beta&amp;t=eYaHFrTLxLHRXHTSzzGbXojZ1_xkEbQFV0KS3MhVf0g"/></div><p>After we step-into again and do a <strong>disas</strong>, we see that we have then moved the value of <strong>0x50</strong> into the <strong>buffer</strong> label as can refer back to the source code from last week to see.</p><p>When dealing with non-register data, we can use the print command above as we type <strong>print /x buffer</strong> and it clearly shows us that the value inside buffer is <strong>0x50</strong>. The <strong>/x</strong> designation means show us the value in hex.</p><div class="slate-resizable-image-embed slate-image-embed__resize-middle"><img src="https://media-exp1.licdn.com/dms/image/C4E12AQFFleubWl_p7A/article-inline_image-shrink_1000_1488/0/1520492696905?e=1614211200&amp;v=beta&amp;t=xdwc4gwJs7Awze7avSEmkhi_kEOkjW8RXETwMHyTqgY"/></div><p>Consequently you can review slide 2 of this tutorial above you see at <strong>_start+5</strong> the immediate value of <strong>0x50</strong> loaded into the <strong>buffer</strong> label or in this case the address of <strong>buffer</strong> which is <strong>0x8049090</strong> and we can examine it by using the examine instruction by typing <strong>x/xb 0x8049090</strong> which shows us one hex byte at that location which yields <strong>0x50.</strong></p><p>We will be doing this with every program example so that we can dive into the debugging process. If there are any questions, please leave them below in the comments.</p><p>I look forward to seeing you all next week when we dive into creating our first assembly hack!</p>